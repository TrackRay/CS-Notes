import Hitokoto from '../../components/hitokoto';
import { Tabs, Tab } from 'nextra/components';

# 数据结构

> <Hitokoto />

## 第七章-查找

### 7.2 顺序查找和折半查找、分块查找

[01.7.2.1顺序查找](https://web.goodnotes.com/s/No7EfUhPHAerrsmV73SYcE)



![image-20230830173215734](https://pic.redhat.team/uPic/image-20230830173215734.png)



[02.7.2.2折半查找](https://web.goodnotes.com/s/RHX5qNsU6NlmBHsgWd3ZWH)

![image-20230830222535259](https://pic.redhat.team/uPic/image-20230830222535259.png)

[03.7.2.3分块查找](https://web.goodnotes.com/s/AVEiM3zxPrODp5uG8FIMqo)

> ***很少考代码，主要靠选择，会手算模拟即可***

![image-20230830225735450](https://pic.redhat.team/uPic/image-20230830225735450.png)

### 7.3 树形查找

[01.7.3.1二叉排序树](https://web.goodnotes.com/s/fotIyDiKSAsqiU48lcTgRO)

![image-20230830231442113](https://pic.redhat.team/uPic/image-20230830231442113.png)

![image-20230830233728102](https://pic.redhat.team/uPic/image-20230830233728102.png)

[02.7.3.2_1平衡二叉树](https://web.goodnotes.com/s/kQa93wOj5nA4hfEsnFYq0M)

> ***考试重点：插入新节点后如何调整“不平衡“（调整最小不平衡子树）问题，主要考选择***

![image-20230831174342634](https://pic.redhat.team/uPic/image-20230831174342634.png)

![image-20230831195557950](https://pic.redhat.team/uPic/image-20230831195557950.png)



[03.7.3.2_2平衡二叉树的删除](https://web.goodnotes.com/s/DujVl9ngkHrE4NdmGlrg1l)

> ***主要讲了各种情况的例子***
>
> ***咸鱼说：2022年以前408没考过，未来考的可能性也不大，理解例1-4即可***

![image-20230831204436636](https://pic.redhat.team/uPic/image-20230831204436636.png)

[04.7.3.3_1红黑树的定义和性质](https://web.goodnotes.com/s/gBCXxAhU7WNfrDz6K77OyX)

> ***重点理解定义、性质，会手绘插入***
>
> ***左根右 根叶黑 不红红 黑路同***

![image-20230831205708038](https://pic.redhat.team/uPic/image-20230831205708038.png)

![image-20230831210503998](https://pic.redhat.team/uPic/image-20230831210503998.png)

![image-20230831211609702](https://pic.redhat.team/uPic/image-20230831211609702.png)

[05.7.3.3_2红黑树的插入](https://web.goodnotes.com/s/ID0LIphGObXlUY0Vjwu3Wf)

> ***看新节点叔叔的脸色***
>
> ***违背不红红***

![image-20230831231524401](https://pic.redhat.team/uPic/image-20230831231524401.png)

![image-20230901173829657](https://pic.redhat.team/uPic/image-20230901173829657.png)

> ***填坑黑高***

![image-20230901174558539](https://pic.redhat.team/uPic/image-20230901174558539.png)

[06.7.3.3_3红黑树的删除](https://web.goodnotes.com/s/myucgsY3dmYiXo9NihwDuw)

> ***不考！！！***

![image-20230901175121180](https://pic.redhat.team/uPic/image-20230901175121180.png)

### 04.7.4 B树和B+树

> **考试当中对B树的考察一般来说是侧重于考察B树的性质，还有关于B树的插入删除查找这几个操作。而对于b数的代码，一般来说不要求掌握，所以我们重点会介绍B树的性质，还有B树的手算方法**

01.7.4.1_1B树

> B树：多路平衡查找树，***难度前三***



![image-20230901224115420](https://pic.redhat.team/uPic/image-20230901224115420.png)

![image-20230901224144181](https://pic.redhat.team/uPic/image-20230901224144181.png)

02.7.4.1_2B树的插入删除

![image-20230901230602920](https://pic.redhat.team/uPic/image-20230901230602920.png)

03.7.4.2B+树

> ***考研当中对B+树的考察一般来说都不会考的特别深，都是考察一些概念性的东西***
>
> **常考与B树的对比**

![image-20230901233236814](https://pic.redhat.team/uPic/image-20230901233236814.png)

![image-20230901234654191](https://pic.redhat.team/uPic/image-20230901234654191.png)

### 05.7.5 散列表

> **简单，就是关键字通过函数映射地址**

[01.7.5.1散列表的基本概念](https://web.goodnotes.com/s/sBlrTp8ELt64q7AzqhwLco)

![image-20230902113805578](https://pic.redhat.team/uPic/image-20230902113805578.png)

[02.7.5.2散列函数的构造](https://web.goodnotes.com/s/WHgVBlKGQ3JnjbW4GfuDY7)

> **最常考除留余数法H(key) = key % p(不大于表长m最接近或等于m的质数)**

![image-20230902120139476](https://pic.redhat.team/uPic/image-20230902120139476.png)

[03.7.5.3_1处理冲突的方法_拉链法](https://web.goodnotes.com/s/sXg76bqHHFRigmf9RCxvRS)

> **拉链法：冲突，丢到链表中；学会分析查找长度（对比次数）**
>
> **散列表通常不考代码，着重掌握手算分析方法**

**插入小优化：**保持链表有序，可以提高查找效率

![image-20230902121324015](https://pic.redhat.team/uPic/image-20230902121324015.png)

[04.7.5.3_2处理冲突的方法_开放定址法](https://web.goodnotes.com/s/1ysRQ8q1tk8uoWGOnMKzag)

> **开放定址法：冲突，找个新位置**

![image-20230902143552934](https://pic.redhat.team/uPic/image-20230902143552934.png)

![image-20230902144330283](https://pic.redhat.team/uPic/image-20230902144330283.png)

## 第八章-排序

### 01.8.1 排序的基本概念

[01.8.1排序的基本概念](https://web.goodnotes.com/s/3W3LnrFeiVEIQf3XLxRxHu)

![image-20230902150348571](https://pic.redhat.team/uPic/image-20230902150348571.png)

### 02.8.2 插入排序

[01.8.2.1+8.2.2插入排序](https://web.goodnotes.com/s/1ysRQ8q1tk8uoWGOnMKzag)

![image-20230902153926509](https://pic.redhat.team/uPic/image-20230902153926509.png)

[02.8.2.3希尔排序](https://web.goodnotes.com/s/1ysRQ8q1tk8uoWGOnMKzag)

> **叫希尔的人发明的，插入的改进；先追求部分有序，再逐渐逼近全局有序（部分->全局）**

**就是重复缩小增量（子表进行直接插入排序），直至增量为1（此时基本有序，然后再对整体进行一次直接插入排序），故又叫缩小增量排序；不稳定，仅适用于顺序表[数组]**

**自述：**按照增量划分多个组，每组进行直接插入排序（手算无所谓，总之每组最终是有序的），然后按照下标对应位置组合在一块，为一趟排序

![IMG_1102](https://pic.redhat.team/uPic/IMG_1102.jpeg)

![image-20230902162631314](https://pic.redhat.team/uPic/image-20230902162631314.png)

### 03.8.3 交换排序

[01.8.3.1冒泡排序]()

**是否适用于链表，看是否需要随机访问元素**

![image-20230902163717498](https://pic.redhat.team/uPic/image-20230902163717498.png)

[02.8.3.2快速排序]()
<Tabs items={['知识点', '真题',]} >

    <Tab>
        > **🌟要会手写代码**

        **自述：通常首元素为枢轴（基准），俩指针在头和尾，依次和枢轴比较，一趟排序确定一个元素的最终位置，剩余部分按上述过程递归执行，直至每部分只有一个元素或为空**

        **优化的话：保证枢轴尽量中分**

        ![image-20230903155855832](https://pic.redhat.team/uPic/image-20230903155855832.png)

        ![image-20230903162910130](https://pic.redhat.team/uPic/image-20230903162910130.png)

        ![image-20230903164415299](https://pic.redhat.team/uPic/image-20230903164415299.png)
    </Tab>

    <Tab>
    **选择题 常考**第X趟排序结果；属于观察即可得答案
    ![IMG_1114](https://pic.redhat.team/uPic/IMG_1114.jpeg)
    </Tab>
</Tabs>


### 04.8.4 选择排序

[01.8.4.1简单选择排序]()

![image-20230903165936507](https://pic.redhat.team/uPic/image-20230903165936507.png)

[02.8.4.2_1堆排序]()

> **硬骨头**

先建堆，再排序（看下图，排序过程中注意**保持大根堆特性**）

![image-20230903184256616](https://pic.redhat.team/uPic/image-20230903184256616.png)

[03.8.4.2_2堆的插入删除]()

> **常考对比关键字的次数，注意：<u>*若有两个孩子，则对比两次*</u>**

新元素放到堆底**；**被删除的元素用堆底元素替代；插入删除之后，要***<u>保持大/小根堆特性</u>***

![image-20230903221256683](https://pic.redhat.team/uPic/image-20230903221256683.png)

### 05.8.5 归并排序和基数排序

[01.8.5.1归并排序]()

> **归并：**把两个或多个已经**有序**的序列**合并**成一个

![image-20230903225318347](https://pic.redhat.team/uPic/image-20230903225318347.png)

[02.8.5.2🐔数排序]()

> **不考代码，会手动模拟即可**，🐔你太**稳**

初始化**r个辅助队列（要递增则从r0开始，递减从r-1开始）**，按**权重递增**次序分配和收集

![image-20230903231509252](https://pic.redhat.team/uPic/image-20230903231509252.png)

![image-20230903232553088](https://pic.redhat.team/uPic/image-20230903232553088.png)

### 06.8.6 各种内部排序算法的比较及应用

![image-20230907170109824](https://pic.redhat.team/uPic/image-20230907170109824.png)

### 07.8.7 外部排序

[01.8.7.1+8.7.2外部排序]()

![image-20230904181254635](https://pic.redhat.team/uPic/image-20230904181254635.png)

**多路平衡归并**

![image-20230904181351708](https://pic.redhat.team/uPic/image-20230904181351708.png)

[02.8.7.3败者树]()

![image-20230904181702756](https://pic.redhat.team/uPic/image-20230904181702756.png)

![image-20230904211228404](https://pic.redhat.team/uPic/image-20230904211228404.png)

[03.8.7.4置换-选择排序]()

> 用于构造**归并段**

**使⽤置换-选择排序，可以让每个初始归并段的⻓度超越内存⼯作区⼤⼩的限制**

![image-20230904213531925](https://pic.redhat.team/uPic/image-20230904213531925.png)

![image-20230904213622554](https://pic.redhat.team/uPic/image-20230904213622554.png)

[04.8.7.5最佳归并树]()

![image-20230904220542941](https://pic.redhat.team/uPic/image-20230904220542941.png)

![image-20230904221910045](https://pic.redhat.team/uPic/image-20230904221910045.png)

![image-20230904222407666](https://pic.redhat.team/uPic/image-20230904222407666.png)

![image-20230904223020251](https://pic.redhat.team/uPic/image-20230904223020251.png)


